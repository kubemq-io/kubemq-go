// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kubemq_go.proto

package pb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strconv "strconv"

import bytes "bytes"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type StreamRequestType int32

const (
	StreamRequestTypeUnknown StreamRequestType = 0
	ReceiveMessage           StreamRequestType = 1
	AckMessage               StreamRequestType = 2
	RejectMessage            StreamRequestType = 3
	ModifyVisibility         StreamRequestType = 4
	ResendMessage            StreamRequestType = 5
	SendModifiedMessage      StreamRequestType = 6
)

var StreamRequestType_name = map[int32]string{
	0: "StreamRequestTypeUnknown",
	1: "ReceiveMessage",
	2: "AckMessage",
	3: "RejectMessage",
	4: "ModifyVisibility",
	5: "ResendMessage",
	6: "SendModifiedMessage",
}
var StreamRequestType_value = map[string]int32{
	"StreamRequestTypeUnknown": 0,
	"ReceiveMessage":           1,
	"AckMessage":               2,
	"RejectMessage":            3,
	"ModifyVisibility":         4,
	"ResendMessage":            5,
	"SendModifiedMessage":      6,
}

func (StreamRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{0}
}

type Subscribe_SubscribeType int32

const (
	SubscribeTypeUndefined Subscribe_SubscribeType = 0
	Events                 Subscribe_SubscribeType = 1
	EventsStore            Subscribe_SubscribeType = 2
	Commands               Subscribe_SubscribeType = 3
	Queries                Subscribe_SubscribeType = 4
)

var Subscribe_SubscribeType_name = map[int32]string{
	0: "SubscribeTypeUndefined",
	1: "Events",
	2: "EventsStore",
	3: "Commands",
	4: "Queries",
}
var Subscribe_SubscribeType_value = map[string]int32{
	"SubscribeTypeUndefined": 0,
	"Events":                 1,
	"EventsStore":            2,
	"Commands":               3,
	"Queries":                4,
}

func (Subscribe_SubscribeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{5, 0}
}

type Subscribe_EventsStoreType int32

const (
	EventsStoreTypeUndefined Subscribe_EventsStoreType = 0
	StartNewOnly             Subscribe_EventsStoreType = 1
	StartFromFirst           Subscribe_EventsStoreType = 2
	StartFromLast            Subscribe_EventsStoreType = 3
	StartAtSequence          Subscribe_EventsStoreType = 4
	StartAtTime              Subscribe_EventsStoreType = 5
	StartAtTimeDelta         Subscribe_EventsStoreType = 6
)

var Subscribe_EventsStoreType_name = map[int32]string{
	0: "EventsStoreTypeUndefined",
	1: "StartNewOnly",
	2: "StartFromFirst",
	3: "StartFromLast",
	4: "StartAtSequence",
	5: "StartAtTime",
	6: "StartAtTimeDelta",
}
var Subscribe_EventsStoreType_value = map[string]int32{
	"EventsStoreTypeUndefined": 0,
	"StartNewOnly":             1,
	"StartFromFirst":           2,
	"StartFromLast":            3,
	"StartAtSequence":          4,
	"StartAtTime":              5,
	"StartAtTimeDelta":         6,
}

func (Subscribe_EventsStoreType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{5, 1}
}

type Request_RequestType int32

const (
	RequestTypeUnknown Request_RequestType = 0
	Command            Request_RequestType = 1
	Query              Request_RequestType = 2
)

var Request_RequestType_name = map[int32]string{
	0: "RequestTypeUnknown",
	1: "Command",
	2: "Query",
}
var Request_RequestType_value = map[string]int32{
	"RequestTypeUnknown": 0,
	"Command":            1,
	"Query":              2,
}

func (Request_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{6, 0}
}

type PingResult struct {
	Host                 string   `protobuf:"bytes,1,opt,name=Host,proto3" json:"Host,omitempty"`
	Version              string   `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	ServerStartTime      int64    `protobuf:"varint,3,opt,name=ServerStartTime,proto3" json:"ServerStartTime,omitempty"`
	ServerUpTimeSeconds  int64    `protobuf:"varint,4,opt,name=ServerUpTimeSeconds,proto3" json:"ServerUpTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingResult) Reset()      { *m = PingResult{} }
func (*PingResult) ProtoMessage() {}
func (*PingResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{0}
}
func (m *PingResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PingResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingResult.Merge(dst, src)
}
func (m *PingResult) XXX_Size() int {
	return m.Size()
}
func (m *PingResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PingResult.DiscardUnknown(m)
}

var xxx_messageInfo_PingResult proto.InternalMessageInfo

func (m *PingResult) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *PingResult) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *PingResult) GetServerStartTime() int64 {
	if m != nil {
		return m.ServerStartTime
	}
	return 0
}

func (m *PingResult) GetServerUpTimeSeconds() int64 {
	if m != nil {
		return m.ServerUpTimeSeconds
	}
	return 0
}

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()      { *m = Empty{} }
func (*Empty) ProtoMessage() {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{1}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Result struct {
	EventID              string   `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Sent                 bool     `protobuf:"varint,2,opt,name=Sent,proto3" json:"Sent,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Result) Reset()      { *m = Result{} }
func (*Result) ProtoMessage() {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{2}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(dst, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Result) GetSent() bool {
	if m != nil {
		return m.Sent
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Event struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	ClientID             string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string            `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Store                bool              `protobuf:"varint,6,opt,name=Store,proto3" json:"Store,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Event) Reset()      { *m = Event{} }
func (*Event) ProtoMessage() {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{3}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(dst, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *Event) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Event) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Event) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Event) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Event) GetStore() bool {
	if m != nil {
		return m.Store
	}
	return false
}

func (m *Event) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type EventReceive struct {
	EventID              string            `protobuf:"bytes,1,opt,name=EventID,proto3" json:"EventID,omitempty"`
	Channel              string            `protobuf:"bytes,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string            `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
	Timestamp            int64             `protobuf:"varint,5,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64            `protobuf:"varint,6,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,7,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EventReceive) Reset()      { *m = EventReceive{} }
func (*EventReceive) ProtoMessage() {}
func (*EventReceive) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{4}
}
func (m *EventReceive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EventReceive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceive.Merge(dst, src)
}
func (m *EventReceive) XXX_Size() int {
	return m.Size()
}
func (m *EventReceive) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceive.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceive proto.InternalMessageInfo

func (m *EventReceive) GetEventID() string {
	if m != nil {
		return m.EventID
	}
	return ""
}

func (m *EventReceive) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *EventReceive) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *EventReceive) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *EventReceive) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventReceive) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *EventReceive) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Subscribe struct {
	SubscribeTypeData    Subscribe_SubscribeType   `protobuf:"varint,1,opt,name=SubscribeTypeData,proto3,enum=kubemq.Subscribe_SubscribeType" json:"SubscribeTypeData,omitempty"`
	ClientID             string                    `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                    `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Group                string                    `protobuf:"bytes,4,opt,name=Group,proto3" json:"Group,omitempty"`
	EventsStoreTypeData  Subscribe_EventsStoreType `protobuf:"varint,5,opt,name=EventsStoreTypeData,proto3,enum=kubemq.Subscribe_EventsStoreType" json:"EventsStoreTypeData,omitempty"`
	EventsStoreTypeValue int64                     `protobuf:"varint,6,opt,name=EventsStoreTypeValue,proto3" json:"EventsStoreTypeValue,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *Subscribe) Reset()      { *m = Subscribe{} }
func (*Subscribe) ProtoMessage() {}
func (*Subscribe) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{5}
}
func (m *Subscribe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subscribe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subscribe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Subscribe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subscribe.Merge(dst, src)
}
func (m *Subscribe) XXX_Size() int {
	return m.Size()
}
func (m *Subscribe) XXX_DiscardUnknown() {
	xxx_messageInfo_Subscribe.DiscardUnknown(m)
}

var xxx_messageInfo_Subscribe proto.InternalMessageInfo

func (m *Subscribe) GetSubscribeTypeData() Subscribe_SubscribeType {
	if m != nil {
		return m.SubscribeTypeData
	}
	return SubscribeTypeUndefined
}

func (m *Subscribe) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Subscribe) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Subscribe) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *Subscribe) GetEventsStoreTypeData() Subscribe_EventsStoreType {
	if m != nil {
		return m.EventsStoreTypeData
	}
	return EventsStoreTypeUndefined
}

func (m *Subscribe) GetEventsStoreTypeValue() int64 {
	if m != nil {
		return m.EventsStoreTypeValue
	}
	return 0
}

type Request struct {
	RequestID            string              `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	RequestTypeData      Request_RequestType `protobuf:"varint,2,opt,name=RequestTypeData,proto3,enum=kubemq.Request_RequestType" json:"RequestTypeData,omitempty"`
	ClientID             string              `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string              `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string              `protobuf:"bytes,5,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte              `protobuf:"bytes,6,opt,name=Body,proto3" json:"Body,omitempty"`
	ReplyChannel         string              `protobuf:"bytes,7,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Timeout              int32               `protobuf:"varint,8,opt,name=Timeout,proto3" json:"Timeout,omitempty"`
	CacheKey             string              `protobuf:"bytes,9,opt,name=CacheKey,proto3" json:"CacheKey,omitempty"`
	CacheTTL             int32               `protobuf:"varint,10,opt,name=CacheTTL,proto3" json:"CacheTTL,omitempty"`
	Span                 []byte              `protobuf:"bytes,11,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string   `protobuf:"bytes,12,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Request) Reset()      { *m = Request{} }
func (*Request) ProtoMessage() {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{6}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(dst, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Request) GetRequestTypeData() Request_RequestType {
	if m != nil {
		return m.RequestTypeData
	}
	return RequestTypeUnknown
}

func (m *Request) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Request) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *Request) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Request) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Request) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Request) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Request) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *Request) GetCacheTTL() int32 {
	if m != nil {
		return m.CacheTTL
	}
	return 0
}

func (m *Request) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Request) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type Response struct {
	ClientID             string            `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	RequestID            string            `protobuf:"bytes,2,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ReplyChannel         string            `protobuf:"bytes,3,opt,name=ReplyChannel,proto3" json:"ReplyChannel,omitempty"`
	Metadata             string            `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte            `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	CacheHit             bool              `protobuf:"varint,6,opt,name=CacheHit,proto3" json:"CacheHit,omitempty"`
	Timestamp            int64             `protobuf:"varint,7,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Executed             bool              `protobuf:"varint,8,opt,name=Executed,proto3" json:"Executed,omitempty"`
	Error                string            `protobuf:"bytes,9,opt,name=Error,proto3" json:"Error,omitempty"`
	Span                 []byte            `protobuf:"bytes,10,opt,name=Span,proto3" json:"Span,omitempty"`
	Tags                 map[string]string `protobuf:"bytes,11,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Response) Reset()      { *m = Response{} }
func (*Response) ProtoMessage() {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{7}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *Response) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *Response) GetReplyChannel() string {
	if m != nil {
		return m.ReplyChannel
	}
	return ""
}

func (m *Response) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Response) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Response) GetCacheHit() bool {
	if m != nil {
		return m.CacheHit
	}
	return false
}

func (m *Response) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Response) GetExecuted() bool {
	if m != nil {
		return m.Executed
	}
	return false
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetSpan() []byte {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *Response) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type QueueMessage struct {
	MessageID            string                  `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	ClientID             string                  `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string                  `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Metadata             string                  `protobuf:"bytes,4,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	Body                 []byte                  `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	Tags                 map[string]string       `protobuf:"bytes,6,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Attributes           *QueueMessageAttributes `protobuf:"bytes,7,opt,name=Attributes" json:"Attributes,omitempty"`
	Policy               *QueueMessagePolicy     `protobuf:"bytes,8,opt,name=Policy" json:"Policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *QueueMessage) Reset()      { *m = QueueMessage{} }
func (*QueueMessage) ProtoMessage() {}
func (*QueueMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{8}
}
func (m *QueueMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueueMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessage.Merge(dst, src)
}
func (m *QueueMessage) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessage.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessage proto.InternalMessageInfo

func (m *QueueMessage) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *QueueMessage) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *QueueMessage) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *QueueMessage) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *QueueMessage) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *QueueMessage) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *QueueMessage) GetAttributes() *QueueMessageAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *QueueMessage) GetPolicy() *QueueMessagePolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

type QueueMessagesBatchRequest struct {
	BatchID              string          `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages" json:"Messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *QueueMessagesBatchRequest) Reset()      { *m = QueueMessagesBatchRequest{} }
func (*QueueMessagesBatchRequest) ProtoMessage() {}
func (*QueueMessagesBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{9}
}
func (m *QueueMessagesBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueueMessagesBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchRequest.Merge(dst, src)
}
func (m *QueueMessagesBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchRequest proto.InternalMessageInfo

func (m *QueueMessagesBatchRequest) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchRequest) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type QueueMessagesBatchResponse struct {
	BatchID              string                    `protobuf:"bytes,1,opt,name=BatchID,proto3" json:"BatchID,omitempty"`
	Results              []*SendQueueMessageResult `protobuf:"bytes,2,rep,name=Results" json:"Results,omitempty"`
	HaveErrors           bool                      `protobuf:"varint,3,opt,name=HaveErrors,proto3" json:"HaveErrors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *QueueMessagesBatchResponse) Reset()      { *m = QueueMessagesBatchResponse{} }
func (*QueueMessagesBatchResponse) ProtoMessage() {}
func (*QueueMessagesBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{10}
}
func (m *QueueMessagesBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagesBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagesBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueueMessagesBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagesBatchResponse.Merge(dst, src)
}
func (m *QueueMessagesBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagesBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagesBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagesBatchResponse proto.InternalMessageInfo

func (m *QueueMessagesBatchResponse) GetBatchID() string {
	if m != nil {
		return m.BatchID
	}
	return ""
}

func (m *QueueMessagesBatchResponse) GetResults() []*SendQueueMessageResult {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *QueueMessagesBatchResponse) GetHaveErrors() bool {
	if m != nil {
		return m.HaveErrors
	}
	return false
}

type QueueMessageAttributes struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Sequence             uint64   `protobuf:"varint,2,opt,name=Sequence,proto3" json:"Sequence,omitempty"`
	MD5OfBody            string   `protobuf:"bytes,3,opt,name=MD5OfBody,proto3" json:"MD5OfBody,omitempty"`
	ReceiveCount         int32    `protobuf:"varint,4,opt,name=ReceiveCount,proto3" json:"ReceiveCount,omitempty"`
	ReRouted             bool     `protobuf:"varint,5,opt,name=ReRouted,proto3" json:"ReRouted,omitempty"`
	ReRoutedFromQueue    string   `protobuf:"bytes,6,opt,name=ReRoutedFromQueue,proto3" json:"ReRoutedFromQueue,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,7,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,8,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessageAttributes) Reset()      { *m = QueueMessageAttributes{} }
func (*QueueMessageAttributes) ProtoMessage() {}
func (*QueueMessageAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{11}
}
func (m *QueueMessageAttributes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessageAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessageAttributes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueueMessageAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessageAttributes.Merge(dst, src)
}
func (m *QueueMessageAttributes) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessageAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessageAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessageAttributes proto.InternalMessageInfo

func (m *QueueMessageAttributes) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *QueueMessageAttributes) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *QueueMessageAttributes) GetMD5OfBody() string {
	if m != nil {
		return m.MD5OfBody
	}
	return ""
}

func (m *QueueMessageAttributes) GetReceiveCount() int32 {
	if m != nil {
		return m.ReceiveCount
	}
	return 0
}

func (m *QueueMessageAttributes) GetReRouted() bool {
	if m != nil {
		return m.ReRouted
	}
	return false
}

func (m *QueueMessageAttributes) GetReRoutedFromQueue() string {
	if m != nil {
		return m.ReRoutedFromQueue
	}
	return ""
}

func (m *QueueMessageAttributes) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *QueueMessageAttributes) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

type QueueMessagePolicy struct {
	ExpirationSeconds    int32    `protobuf:"varint,1,opt,name=ExpirationSeconds,proto3" json:"ExpirationSeconds,omitempty"`
	DelaySeconds         int32    `protobuf:"varint,2,opt,name=DelaySeconds,proto3" json:"DelaySeconds,omitempty"`
	MaxReceiveCount      int32    `protobuf:"varint,3,opt,name=MaxReceiveCount,proto3" json:"MaxReceiveCount,omitempty"`
	MaxReceiveQueue      string   `protobuf:"bytes,4,opt,name=MaxReceiveQueue,proto3" json:"MaxReceiveQueue,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessagePolicy) Reset()      { *m = QueueMessagePolicy{} }
func (*QueueMessagePolicy) ProtoMessage() {}
func (*QueueMessagePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{12}
}
func (m *QueueMessagePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessagePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessagePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueueMessagePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessagePolicy.Merge(dst, src)
}
func (m *QueueMessagePolicy) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessagePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessagePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessagePolicy proto.InternalMessageInfo

func (m *QueueMessagePolicy) GetExpirationSeconds() int32 {
	if m != nil {
		return m.ExpirationSeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetDelaySeconds() int32 {
	if m != nil {
		return m.DelaySeconds
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveCount() int32 {
	if m != nil {
		return m.MaxReceiveCount
	}
	return 0
}

func (m *QueueMessagePolicy) GetMaxReceiveQueue() string {
	if m != nil {
		return m.MaxReceiveQueue
	}
	return ""
}

type SendQueueMessageResult struct {
	MessageID            string   `protobuf:"bytes,1,opt,name=MessageID,proto3" json:"MessageID,omitempty"`
	SentAt               int64    `protobuf:"varint,2,opt,name=SentAt,proto3" json:"SentAt,omitempty"`
	ExpirationAt         int64    `protobuf:"varint,3,opt,name=ExpirationAt,proto3" json:"ExpirationAt,omitempty"`
	DelayedTo            int64    `protobuf:"varint,4,opt,name=DelayedTo,proto3" json:"DelayedTo,omitempty"`
	IsError              bool     `protobuf:"varint,5,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,6,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SendQueueMessageResult) Reset()      { *m = SendQueueMessageResult{} }
func (*SendQueueMessageResult) ProtoMessage() {}
func (*SendQueueMessageResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{13}
}
func (m *SendQueueMessageResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendQueueMessageResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendQueueMessageResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SendQueueMessageResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendQueueMessageResult.Merge(dst, src)
}
func (m *SendQueueMessageResult) XXX_Size() int {
	return m.Size()
}
func (m *SendQueueMessageResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SendQueueMessageResult.DiscardUnknown(m)
}

var xxx_messageInfo_SendQueueMessageResult proto.InternalMessageInfo

func (m *SendQueueMessageResult) GetMessageID() string {
	if m != nil {
		return m.MessageID
	}
	return ""
}

func (m *SendQueueMessageResult) GetSentAt() int64 {
	if m != nil {
		return m.SentAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetExpirationAt() int64 {
	if m != nil {
		return m.ExpirationAt
	}
	return 0
}

func (m *SendQueueMessageResult) GetDelayedTo() int64 {
	if m != nil {
		return m.DelayedTo
	}
	return 0
}

func (m *SendQueueMessageResult) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *SendQueueMessageResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ReceiveQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	MaxNumberOfMessages  int32    `protobuf:"varint,4,opt,name=MaxNumberOfMessages,proto3" json:"MaxNumberOfMessages,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,5,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	IsPeak               bool     `protobuf:"varint,6,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiveQueueMessagesRequest) Reset()      { *m = ReceiveQueueMessagesRequest{} }
func (*ReceiveQueueMessagesRequest) ProtoMessage() {}
func (*ReceiveQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{14}
}
func (m *ReceiveQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReceiveQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesRequest.Merge(dst, src)
}
func (m *ReceiveQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesRequest proto.InternalMessageInfo

func (m *ReceiveQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *ReceiveQueueMessagesRequest) GetMaxNumberOfMessages() int32 {
	if m != nil {
		return m.MaxNumberOfMessages
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *ReceiveQueueMessagesRequest) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

type ReceiveQueueMessagesResponse struct {
	RequestID            string          `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	Messages             []*QueueMessage `protobuf:"bytes,2,rep,name=Messages" json:"Messages,omitempty"`
	MessagesReceived     int32           `protobuf:"varint,3,opt,name=MessagesReceived,proto3" json:"MessagesReceived,omitempty"`
	MessagesExpired      int32           `protobuf:"varint,4,opt,name=MessagesExpired,proto3" json:"MessagesExpired,omitempty"`
	IsPeak               bool            `protobuf:"varint,5,opt,name=IsPeak,proto3" json:"IsPeak,omitempty"`
	IsError              bool            `protobuf:"varint,6,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string          `protobuf:"bytes,7,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReceiveQueueMessagesResponse) Reset()      { *m = ReceiveQueueMessagesResponse{} }
func (*ReceiveQueueMessagesResponse) ProtoMessage() {}
func (*ReceiveQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{15}
}
func (m *ReceiveQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ReceiveQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveQueueMessagesResponse.Merge(dst, src)
}
func (m *ReceiveQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveQueueMessagesResponse proto.InternalMessageInfo

func (m *ReceiveQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *ReceiveQueueMessagesResponse) GetMessages() []*QueueMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *ReceiveQueueMessagesResponse) GetMessagesReceived() int32 {
	if m != nil {
		return m.MessagesReceived
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetMessagesExpired() int32 {
	if m != nil {
		return m.MessagesExpired
	}
	return 0
}

func (m *ReceiveQueueMessagesResponse) GetIsPeak() bool {
	if m != nil {
		return m.IsPeak
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *ReceiveQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type AckAllQueueMessagesRequest struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Channel              string   `protobuf:"bytes,3,opt,name=Channel,proto3" json:"Channel,omitempty"`
	WaitTimeSeconds      int32    `protobuf:"varint,4,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesRequest) Reset()      { *m = AckAllQueueMessagesRequest{} }
func (*AckAllQueueMessagesRequest) ProtoMessage() {}
func (*AckAllQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{16}
}
func (m *AckAllQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AckAllQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesRequest.Merge(dst, src)
}
func (m *AckAllQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesRequest proto.InternalMessageInfo

func (m *AckAllQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *AckAllQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

type AckAllQueueMessagesResponse struct {
	RequestID            string   `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	AffectedMessages     uint64   `protobuf:"varint,2,opt,name=AffectedMessages,proto3" json:"AffectedMessages,omitempty"`
	IsError              bool     `protobuf:"varint,3,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                string   `protobuf:"bytes,4,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AckAllQueueMessagesResponse) Reset()      { *m = AckAllQueueMessagesResponse{} }
func (*AckAllQueueMessagesResponse) ProtoMessage() {}
func (*AckAllQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{17}
}
func (m *AckAllQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AckAllQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AckAllQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AckAllQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AckAllQueueMessagesResponse.Merge(dst, src)
}
func (m *AckAllQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AckAllQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AckAllQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AckAllQueueMessagesResponse proto.InternalMessageInfo

func (m *AckAllQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *AckAllQueueMessagesResponse) GetAffectedMessages() uint64 {
	if m != nil {
		return m.AffectedMessages
	}
	return 0
}

func (m *AckAllQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *AckAllQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type StreamQueueMessagesRequest struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	ClientID              string            `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,3,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Channel               string            `protobuf:"bytes,4,opt,name=Channel,proto3" json:"Channel,omitempty"`
	VisibilitySeconds     int32             `protobuf:"varint,5,opt,name=VisibilitySeconds,proto3" json:"VisibilitySeconds,omitempty"`
	WaitTimeSeconds       int32             `protobuf:"varint,6,opt,name=WaitTimeSeconds,proto3" json:"WaitTimeSeconds,omitempty"`
	RefSequence           uint64            `protobuf:"varint,7,opt,name=RefSequence,proto3" json:"RefSequence,omitempty"`
	ModifiedMessage       *QueueMessage     `protobuf:"bytes,8,opt,name=ModifiedMessage" json:"ModifiedMessage,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesRequest) Reset()      { *m = StreamQueueMessagesRequest{} }
func (*StreamQueueMessagesRequest) ProtoMessage() {}
func (*StreamQueueMessagesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{18}
}
func (m *StreamQueueMessagesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StreamQueueMessagesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesRequest.Merge(dst, src)
}
func (m *StreamQueueMessagesRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesRequest proto.InternalMessageInfo

func (m *StreamQueueMessagesRequest) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *StreamQueueMessagesRequest) GetVisibilitySeconds() int32 {
	if m != nil {
		return m.VisibilitySeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetWaitTimeSeconds() int32 {
	if m != nil {
		return m.WaitTimeSeconds
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetRefSequence() uint64 {
	if m != nil {
		return m.RefSequence
	}
	return 0
}

func (m *StreamQueueMessagesRequest) GetModifiedMessage() *QueueMessage {
	if m != nil {
		return m.ModifiedMessage
	}
	return nil
}

type StreamQueueMessagesResponse struct {
	RequestID             string            `protobuf:"bytes,1,opt,name=RequestID,proto3" json:"RequestID,omitempty"`
	StreamRequestTypeData StreamRequestType `protobuf:"varint,2,opt,name=StreamRequestTypeData,proto3,enum=kubemq.StreamRequestType" json:"StreamRequestTypeData,omitempty"`
	Message               *QueueMessage     `protobuf:"bytes,3,opt,name=Message" json:"Message,omitempty"`
	IsError               bool              `protobuf:"varint,4,opt,name=IsError,proto3" json:"IsError,omitempty"`
	Error                 string            `protobuf:"bytes,5,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}          `json:"-"`
	XXX_sizecache         int32             `json:"-"`
}

func (m *StreamQueueMessagesResponse) Reset()      { *m = StreamQueueMessagesResponse{} }
func (*StreamQueueMessagesResponse) ProtoMessage() {}
func (*StreamQueueMessagesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_kubemq_go_0ff2ba662d4a1703, []int{19}
}
func (m *StreamQueueMessagesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamQueueMessagesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamQueueMessagesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StreamQueueMessagesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamQueueMessagesResponse.Merge(dst, src)
}
func (m *StreamQueueMessagesResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamQueueMessagesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamQueueMessagesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamQueueMessagesResponse proto.InternalMessageInfo

func (m *StreamQueueMessagesResponse) GetRequestID() string {
	if m != nil {
		return m.RequestID
	}
	return ""
}

func (m *StreamQueueMessagesResponse) GetStreamRequestTypeData() StreamRequestType {
	if m != nil {
		return m.StreamRequestTypeData
	}
	return StreamRequestTypeUnknown
}

func (m *StreamQueueMessagesResponse) GetMessage() *QueueMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *StreamQueueMessagesResponse) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *StreamQueueMessagesResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*PingResult)(nil), "kubemq.PingResult")
	proto.RegisterType((*Empty)(nil), "kubemq.Empty")
	proto.RegisterType((*Result)(nil), "kubemq.Result")
	proto.RegisterType((*Event)(nil), "kubemq.Event")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Event.TagsEntry")
	proto.RegisterType((*EventReceive)(nil), "kubemq.EventReceive")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.EventReceive.TagsEntry")
	proto.RegisterType((*Subscribe)(nil), "kubemq.Subscribe")
	proto.RegisterType((*Request)(nil), "kubemq.Request")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Request.TagsEntry")
	proto.RegisterType((*Response)(nil), "kubemq.Response")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.Response.TagsEntry")
	proto.RegisterType((*QueueMessage)(nil), "kubemq.QueueMessage")
	proto.RegisterMapType((map[string]string)(nil), "kubemq.QueueMessage.TagsEntry")
	proto.RegisterType((*QueueMessagesBatchRequest)(nil), "kubemq.QueueMessagesBatchRequest")
	proto.RegisterType((*QueueMessagesBatchResponse)(nil), "kubemq.QueueMessagesBatchResponse")
	proto.RegisterType((*QueueMessageAttributes)(nil), "kubemq.QueueMessageAttributes")
	proto.RegisterType((*QueueMessagePolicy)(nil), "kubemq.QueueMessagePolicy")
	proto.RegisterType((*SendQueueMessageResult)(nil), "kubemq.SendQueueMessageResult")
	proto.RegisterType((*ReceiveQueueMessagesRequest)(nil), "kubemq.ReceiveQueueMessagesRequest")
	proto.RegisterType((*ReceiveQueueMessagesResponse)(nil), "kubemq.ReceiveQueueMessagesResponse")
	proto.RegisterType((*AckAllQueueMessagesRequest)(nil), "kubemq.AckAllQueueMessagesRequest")
	proto.RegisterType((*AckAllQueueMessagesResponse)(nil), "kubemq.AckAllQueueMessagesResponse")
	proto.RegisterType((*StreamQueueMessagesRequest)(nil), "kubemq.StreamQueueMessagesRequest")
	proto.RegisterType((*StreamQueueMessagesResponse)(nil), "kubemq.StreamQueueMessagesResponse")
	proto.RegisterEnum("kubemq.StreamRequestType", StreamRequestType_name, StreamRequestType_value)
	proto.RegisterEnum("kubemq.Subscribe_SubscribeType", Subscribe_SubscribeType_name, Subscribe_SubscribeType_value)
	proto.RegisterEnum("kubemq.Subscribe_EventsStoreType", Subscribe_EventsStoreType_name, Subscribe_EventsStoreType_value)
	proto.RegisterEnum("kubemq.Request_RequestType", Request_RequestType_name, Request_RequestType_value)
}
func (x StreamRequestType) String() string {
	s, ok := StreamRequestType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Subscribe_SubscribeType) String() string {
	s, ok := Subscribe_SubscribeType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Subscribe_EventsStoreType) String() string {
	s, ok := Subscribe_EventsStoreType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Request_RequestType) String() string {
	s, ok := Request_RequestType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *PingResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PingResult)
	if !ok {
		that2, ok := that.(PingResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Host != that1.Host {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ServerStartTime != that1.ServerStartTime {
		return false
	}
	if this.ServerUpTimeSeconds != that1.ServerUpTimeSeconds {
		return false
	}
	return true
}
func (this *Empty) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Empty)
	if !ok {
		that2, ok := that.(Empty)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *Result) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Result)
	if !ok {
		that2, ok := that.(Result)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Sent != that1.Sent {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *Event) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Event)
	if !ok {
		that2, ok := that.(Event)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Store != that1.Store {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *EventReceive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventReceive)
	if !ok {
		that2, ok := that.(EventReceive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventID != that1.EventID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *Subscribe) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Subscribe)
	if !ok {
		that2, ok := that.(Subscribe)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SubscribeTypeData != that1.SubscribeTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if this.EventsStoreTypeData != that1.EventsStoreTypeData {
		return false
	}
	if this.EventsStoreTypeValue != that1.EventsStoreTypeValue {
		return false
	}
	return true
}
func (this *Request) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Request)
	if !ok {
		that2, ok := that.(Request)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.RequestTypeData != that1.RequestTypeData {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if this.CacheKey != that1.CacheKey {
		return false
	}
	if this.CacheTTL != that1.CacheTTL {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *Response) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Response)
	if !ok {
		that2, ok := that.(Response)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ReplyChannel != that1.ReplyChannel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if this.CacheHit != that1.CacheHit {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Executed != that1.Executed {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	if !bytes.Equal(this.Span, that1.Span) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	return true
}
func (this *QueueMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessage)
	if !ok {
		that2, ok := that.(QueueMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !bytes.Equal(this.Body, that1.Body) {
		return false
	}
	if len(this.Tags) != len(that1.Tags) {
		return false
	}
	for i := range this.Tags {
		if this.Tags[i] != that1.Tags[i] {
			return false
		}
	}
	if !this.Attributes.Equal(that1.Attributes) {
		return false
	}
	if !this.Policy.Equal(that1.Policy) {
		return false
	}
	return true
}
func (this *QueueMessagesBatchRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchRequest)
	if !ok {
		that2, ok := that.(QueueMessagesBatchRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *QueueMessagesBatchResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagesBatchResponse)
	if !ok {
		that2, ok := that.(QueueMessagesBatchResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BatchID != that1.BatchID {
		return false
	}
	if len(this.Results) != len(that1.Results) {
		return false
	}
	for i := range this.Results {
		if !this.Results[i].Equal(that1.Results[i]) {
			return false
		}
	}
	if this.HaveErrors != that1.HaveErrors {
		return false
	}
	return true
}
func (this *QueueMessageAttributes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessageAttributes)
	if !ok {
		that2, ok := that.(QueueMessageAttributes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Sequence != that1.Sequence {
		return false
	}
	if this.MD5OfBody != that1.MD5OfBody {
		return false
	}
	if this.ReceiveCount != that1.ReceiveCount {
		return false
	}
	if this.ReRouted != that1.ReRouted {
		return false
	}
	if this.ReRoutedFromQueue != that1.ReRoutedFromQueue {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	return true
}
func (this *QueueMessagePolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueueMessagePolicy)
	if !ok {
		that2, ok := that.(QueueMessagePolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpirationSeconds != that1.ExpirationSeconds {
		return false
	}
	if this.DelaySeconds != that1.DelaySeconds {
		return false
	}
	if this.MaxReceiveCount != that1.MaxReceiveCount {
		return false
	}
	if this.MaxReceiveQueue != that1.MaxReceiveQueue {
		return false
	}
	return true
}
func (this *SendQueueMessageResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendQueueMessageResult)
	if !ok {
		that2, ok := that.(SendQueueMessageResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageID != that1.MessageID {
		return false
	}
	if this.SentAt != that1.SentAt {
		return false
	}
	if this.ExpirationAt != that1.ExpirationAt {
		return false
	}
	if this.DelayedTo != that1.DelayedTo {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesRequest)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.MaxNumberOfMessages != that1.MaxNumberOfMessages {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	return true
}
func (this *ReceiveQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReceiveQueueMessagesResponse)
	if !ok {
		that2, ok := that.(ReceiveQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	if this.MessagesReceived != that1.MessagesReceived {
		return false
	}
	if this.MessagesExpired != that1.MessagesExpired {
		return false
	}
	if this.IsPeak != that1.IsPeak {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesRequest)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	return true
}
func (this *AckAllQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AckAllQueueMessagesResponse)
	if !ok {
		that2, ok := that.(AckAllQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.AffectedMessages != that1.AffectedMessages {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *StreamQueueMessagesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesRequest)
	if !ok {
		that2, ok := that.(StreamQueueMessagesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.ClientID != that1.ClientID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if this.Channel != that1.Channel {
		return false
	}
	if this.VisibilitySeconds != that1.VisibilitySeconds {
		return false
	}
	if this.WaitTimeSeconds != that1.WaitTimeSeconds {
		return false
	}
	if this.RefSequence != that1.RefSequence {
		return false
	}
	if !this.ModifiedMessage.Equal(that1.ModifiedMessage) {
		return false
	}
	return true
}
func (this *StreamQueueMessagesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamQueueMessagesResponse)
	if !ok {
		that2, ok := that.(StreamQueueMessagesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequestID != that1.RequestID {
		return false
	}
	if this.StreamRequestTypeData != that1.StreamRequestTypeData {
		return false
	}
	if !this.Message.Equal(that1.Message) {
		return false
	}
	if this.IsError != that1.IsError {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *PingResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.PingResult{")
	s = append(s, "Host: "+fmt.Sprintf("%#v", this.Host)+",\n")
	s = append(s, "Version: "+fmt.Sprintf("%#v", this.Version)+",\n")
	s = append(s, "ServerStartTime: "+fmt.Sprintf("%#v", this.ServerStartTime)+",\n")
	s = append(s, "ServerUpTimeSeconds: "+fmt.Sprintf("%#v", this.ServerUpTimeSeconds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Empty) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&kubemq.Empty{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Result) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.Result{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Sent: "+fmt.Sprintf("%#v", this.Sent)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Event) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.Event{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Store: "+fmt.Sprintf("%#v", this.Store)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EventReceive) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.EventReceive{")
	s = append(s, "EventID: "+fmt.Sprintf("%#v", this.EventID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Subscribe) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.Subscribe{")
	s = append(s, "SubscribeTypeData: "+fmt.Sprintf("%#v", this.SubscribeTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "EventsStoreTypeData: "+fmt.Sprintf("%#v", this.EventsStoreTypeData)+",\n")
	s = append(s, "EventsStoreTypeValue: "+fmt.Sprintf("%#v", this.EventsStoreTypeValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Request) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&kubemq.Request{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "RequestTypeData: "+fmt.Sprintf("%#v", this.RequestTypeData)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "CacheKey: "+fmt.Sprintf("%#v", this.CacheKey)+",\n")
	s = append(s, "CacheTTL: "+fmt.Sprintf("%#v", this.CacheTTL)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Response) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&kubemq.Response{")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ReplyChannel: "+fmt.Sprintf("%#v", this.ReplyChannel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	s = append(s, "CacheHit: "+fmt.Sprintf("%#v", this.CacheHit)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Executed: "+fmt.Sprintf("%#v", this.Executed)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "Span: "+fmt.Sprintf("%#v", this.Span)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.QueueMessage{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "Metadata: "+fmt.Sprintf("%#v", this.Metadata)+",\n")
	s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%#v: %#v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	if this.Tags != nil {
		s = append(s, "Tags: "+mapStringForTags+",\n")
	}
	if this.Attributes != nil {
		s = append(s, "Attributes: "+fmt.Sprintf("%#v", this.Attributes)+",\n")
	}
	if this.Policy != nil {
		s = append(s, "Policy: "+fmt.Sprintf("%#v", this.Policy)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&kubemq.QueueMessagesBatchRequest{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagesBatchResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&kubemq.QueueMessagesBatchResponse{")
	s = append(s, "BatchID: "+fmt.Sprintf("%#v", this.BatchID)+",\n")
	if this.Results != nil {
		s = append(s, "Results: "+fmt.Sprintf("%#v", this.Results)+",\n")
	}
	s = append(s, "HaveErrors: "+fmt.Sprintf("%#v", this.HaveErrors)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessageAttributes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.QueueMessageAttributes{")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Sequence: "+fmt.Sprintf("%#v", this.Sequence)+",\n")
	s = append(s, "MD5OfBody: "+fmt.Sprintf("%#v", this.MD5OfBody)+",\n")
	s = append(s, "ReceiveCount: "+fmt.Sprintf("%#v", this.ReceiveCount)+",\n")
	s = append(s, "ReRouted: "+fmt.Sprintf("%#v", this.ReRouted)+",\n")
	s = append(s, "ReRoutedFromQueue: "+fmt.Sprintf("%#v", this.ReRoutedFromQueue)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *QueueMessagePolicy) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.QueueMessagePolicy{")
	s = append(s, "ExpirationSeconds: "+fmt.Sprintf("%#v", this.ExpirationSeconds)+",\n")
	s = append(s, "DelaySeconds: "+fmt.Sprintf("%#v", this.DelaySeconds)+",\n")
	s = append(s, "MaxReceiveCount: "+fmt.Sprintf("%#v", this.MaxReceiveCount)+",\n")
	s = append(s, "MaxReceiveQueue: "+fmt.Sprintf("%#v", this.MaxReceiveQueue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendQueueMessageResult) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.SendQueueMessageResult{")
	s = append(s, "MessageID: "+fmt.Sprintf("%#v", this.MessageID)+",\n")
	s = append(s, "SentAt: "+fmt.Sprintf("%#v", this.SentAt)+",\n")
	s = append(s, "ExpirationAt: "+fmt.Sprintf("%#v", this.ExpirationAt)+",\n")
	s = append(s, "DelayedTo: "+fmt.Sprintf("%#v", this.DelayedTo)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&kubemq.ReceiveQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "MaxNumberOfMessages: "+fmt.Sprintf("%#v", this.MaxNumberOfMessages)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReceiveQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&kubemq.ReceiveQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	if this.Messages != nil {
		s = append(s, "Messages: "+fmt.Sprintf("%#v", this.Messages)+",\n")
	}
	s = append(s, "MessagesReceived: "+fmt.Sprintf("%#v", this.MessagesReceived)+",\n")
	s = append(s, "MessagesExpired: "+fmt.Sprintf("%#v", this.MessagesExpired)+",\n")
	s = append(s, "IsPeak: "+fmt.Sprintf("%#v", this.IsPeak)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AckAllQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&kubemq.AckAllQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "AffectedMessages: "+fmt.Sprintf("%#v", this.AffectedMessages)+",\n")
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&kubemq.StreamQueueMessagesRequest{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "ClientID: "+fmt.Sprintf("%#v", this.ClientID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	s = append(s, "Channel: "+fmt.Sprintf("%#v", this.Channel)+",\n")
	s = append(s, "VisibilitySeconds: "+fmt.Sprintf("%#v", this.VisibilitySeconds)+",\n")
	s = append(s, "WaitTimeSeconds: "+fmt.Sprintf("%#v", this.WaitTimeSeconds)+",\n")
	s = append(s, "RefSequence: "+fmt.Sprintf("%#v", this.RefSequence)+",\n")
	if this.ModifiedMessage != nil {
		s = append(s, "ModifiedMessage: "+fmt.Sprintf("%#v", this.ModifiedMessage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamQueueMessagesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&kubemq.StreamQueueMessagesResponse{")
	s = append(s, "RequestID: "+fmt.Sprintf("%#v", this.RequestID)+",\n")
	s = append(s, "StreamRequestTypeData: "+fmt.Sprintf("%#v", this.StreamRequestTypeData)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	s = append(s, "IsError: "+fmt.Sprintf("%#v", this.IsError)+",\n")
	s = append(s, "Error: "+fmt.Sprintf("%#v", this.Error)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringKubemqGo(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Kubemq service

type KubemqClient interface {
	SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error)
	SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error)
	SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error)
	SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error)
	SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error)
	SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error)
	AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error)
}

type kubemqClient struct {
	cc *grpc.ClientConn
}

func NewKubemqClient(cc *grpc.ClientConn) KubemqClient {
	return &kubemqClient{cc}
}

func (c *kubemqClient) SendEvent(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendEventsStream(ctx context.Context, opts ...grpc.CallOption) (Kubemq_SendEventsStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[0], "/kubemq.kubemq/SendEventsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSendEventsStreamClient{stream}
	return x, nil
}

type Kubemq_SendEventsStreamClient interface {
	Send(*Event) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type kubemqSendEventsStreamClient struct {
	grpc.ClientStream
}

func (x *kubemqSendEventsStreamClient) Send(m *Event) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToEvents(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[1], "/kubemq.kubemq/SubscribeToEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToEventsClient interface {
	Recv() (*EventReceive, error)
	grpc.ClientStream
}

type kubemqSubscribeToEventsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToEventsClient) Recv() (*EventReceive, error) {
	m := new(EventReceive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SubscribeToRequests(ctx context.Context, in *Subscribe, opts ...grpc.CallOption) (Kubemq_SubscribeToRequestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[2], "/kubemq.kubemq/SubscribeToRequests", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqSubscribeToRequestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Kubemq_SubscribeToRequestsClient interface {
	Recv() (*Request, error)
	grpc.ClientStream
}

type kubemqSubscribeToRequestsClient struct {
	grpc.ClientStream
}

func (x *kubemqSubscribeToRequestsClient) Recv() (*Request, error) {
	m := new(Request)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) SendRequest(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendResponse(ctx context.Context, in *Response, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendResponse", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessage(ctx context.Context, in *QueueMessage, opts ...grpc.CallOption) (*SendQueueMessageResult, error) {
	out := new(SendQueueMessageResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) SendQueueMessagesBatch(ctx context.Context, in *QueueMessagesBatchRequest, opts ...grpc.CallOption) (*QueueMessagesBatchResponse, error) {
	out := new(QueueMessagesBatchResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/SendQueueMessagesBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) ReceiveQueueMessages(ctx context.Context, in *ReceiveQueueMessagesRequest, opts ...grpc.CallOption) (*ReceiveQueueMessagesResponse, error) {
	out := new(ReceiveQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/ReceiveQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) StreamQueueMessage(ctx context.Context, opts ...grpc.CallOption) (Kubemq_StreamQueueMessageClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Kubemq_serviceDesc.Streams[3], "/kubemq.kubemq/StreamQueueMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &kubemqStreamQueueMessageClient{stream}
	return x, nil
}

type Kubemq_StreamQueueMessageClient interface {
	Send(*StreamQueueMessagesRequest) error
	Recv() (*StreamQueueMessagesResponse, error)
	grpc.ClientStream
}

type kubemqStreamQueueMessageClient struct {
	grpc.ClientStream
}

func (x *kubemqStreamQueueMessageClient) Send(m *StreamQueueMessagesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageClient) Recv() (*StreamQueueMessagesResponse, error) {
	m := new(StreamQueueMessagesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *kubemqClient) AckAllQueueMessages(ctx context.Context, in *AckAllQueueMessagesRequest, opts ...grpc.CallOption) (*AckAllQueueMessagesResponse, error) {
	out := new(AckAllQueueMessagesResponse)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/AckAllQueueMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kubemqClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*PingResult, error) {
	out := new(PingResult)
	err := c.cc.Invoke(ctx, "/kubemq.kubemq/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Kubemq service

type KubemqServer interface {
	SendEvent(context.Context, *Event) (*Result, error)
	SendEventsStream(Kubemq_SendEventsStreamServer) error
	SubscribeToEvents(*Subscribe, Kubemq_SubscribeToEventsServer) error
	SubscribeToRequests(*Subscribe, Kubemq_SubscribeToRequestsServer) error
	SendRequest(context.Context, *Request) (*Response, error)
	SendResponse(context.Context, *Response) (*Empty, error)
	SendQueueMessage(context.Context, *QueueMessage) (*SendQueueMessageResult, error)
	SendQueueMessagesBatch(context.Context, *QueueMessagesBatchRequest) (*QueueMessagesBatchResponse, error)
	ReceiveQueueMessages(context.Context, *ReceiveQueueMessagesRequest) (*ReceiveQueueMessagesResponse, error)
	StreamQueueMessage(Kubemq_StreamQueueMessageServer) error
	AckAllQueueMessages(context.Context, *AckAllQueueMessagesRequest) (*AckAllQueueMessagesResponse, error)
	Ping(context.Context, *Empty) (*PingResult, error)
}

func RegisterKubemqServer(s *grpc.Server, srv KubemqServer) {
	s.RegisterService(&_Kubemq_serviceDesc, srv)
}

func _Kubemq_SendEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendEvent(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendEventsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).SendEventsStream(&kubemqSendEventsStreamServer{stream})
}

type Kubemq_SendEventsStreamServer interface {
	Send(*Result) error
	Recv() (*Event, error)
	grpc.ServerStream
}

type kubemqSendEventsStreamServer struct {
	grpc.ServerStream
}

func (x *kubemqSendEventsStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqSendEventsStreamServer) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToEvents(m, &kubemqSubscribeToEventsServer{stream})
}

type Kubemq_SubscribeToEventsServer interface {
	Send(*EventReceive) error
	grpc.ServerStream
}

type kubemqSubscribeToEventsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToEventsServer) Send(m *EventReceive) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SubscribeToRequests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscribe)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KubemqServer).SubscribeToRequests(m, &kubemqSubscribeToRequestsServer{stream})
}

type Kubemq_SubscribeToRequestsServer interface {
	Send(*Request) error
	grpc.ServerStream
}

type kubemqSubscribeToRequestsServer struct {
	grpc.ServerStream
}

func (x *kubemqSubscribeToRequestsServer) Send(m *Request) error {
	return x.ServerStream.SendMsg(m)
}

func _Kubemq_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendRequest(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendResponse(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessage(ctx, req.(*QueueMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_SendQueueMessagesBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueueMessagesBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/SendQueueMessagesBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).SendQueueMessagesBatch(ctx, req.(*QueueMessagesBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_ReceiveQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/ReceiveQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).ReceiveQueueMessages(ctx, req.(*ReceiveQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_StreamQueueMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KubemqServer).StreamQueueMessage(&kubemqStreamQueueMessageServer{stream})
}

type Kubemq_StreamQueueMessageServer interface {
	Send(*StreamQueueMessagesResponse) error
	Recv() (*StreamQueueMessagesRequest, error)
	grpc.ServerStream
}

type kubemqStreamQueueMessageServer struct {
	grpc.ServerStream
}

func (x *kubemqStreamQueueMessageServer) Send(m *StreamQueueMessagesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *kubemqStreamQueueMessageServer) Recv() (*StreamQueueMessagesRequest, error) {
	m := new(StreamQueueMessagesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Kubemq_AckAllQueueMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckAllQueueMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/AckAllQueueMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).AckAllQueueMessages(ctx, req.(*AckAllQueueMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kubemq_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KubemqServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kubemq.kubemq/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KubemqServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Kubemq_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kubemq.kubemq",
	HandlerType: (*KubemqServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendEvent",
			Handler:    _Kubemq_SendEvent_Handler,
		},
		{
			MethodName: "SendRequest",
			Handler:    _Kubemq_SendRequest_Handler,
		},
		{
			MethodName: "SendResponse",
			Handler:    _Kubemq_SendResponse_Handler,
		},
		{
			MethodName: "SendQueueMessage",
			Handler:    _Kubemq_SendQueueMessage_Handler,
		},
		{
			MethodName: "SendQueueMessagesBatch",
			Handler:    _Kubemq_SendQueueMessagesBatch_Handler,
		},
		{
			MethodName: "ReceiveQueueMessages",
			Handler:    _Kubemq_ReceiveQueueMessages_Handler,
		},
		{
			MethodName: "AckAllQueueMessages",
			Handler:    _Kubemq_AckAllQueueMessages_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Kubemq_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendEventsStream",
			Handler:       _Kubemq_SendEventsStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _Kubemq_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToRequests",
			Handler:       _Kubemq_SubscribeToRequests_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamQueueMessage",
			Handler:       _Kubemq_StreamQueueMessage_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "kubemq_go.proto",
}

func (m *PingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ServerStartTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ServerUpTimeSeconds))
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if m.Sent {
		dAtA[i] = 0x10
		i++
		if m.Sent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Store {
		dAtA[i] = 0x30
		i++
		if m.Store {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *EventReceive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.EventID)))
		i += copy(dAtA[i:], m.EventID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x3a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Subscribe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subscribe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SubscribeTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Group) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Group)))
		i += copy(dAtA[i:], m.Group)
	}
	if m.EventsStoreTypeData != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.EventsStoreTypeValue))
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.RequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RequestTypeData))
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timeout))
	}
	if len(m.CacheKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.CacheKey)))
		i += copy(dAtA[i:], m.CacheKey)
	}
	if m.CacheTTL != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.CacheTTL))
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x62
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.RequestID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ReplyChannel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReplyChannel)))
		i += copy(dAtA[i:], m.ReplyChannel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if m.CacheHit {
		dAtA[i] = 0x30
		i++
		if m.CacheHit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Executed {
		dAtA[i] = 0x40
		i++
		if m.Executed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Span) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Span)))
		i += copy(dAtA[i:], m.Span)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x5a
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *QueueMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Metadata) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	if len(m.Tags) > 0 {
		for k, _ := range m.Tags {
			dAtA[i] = 0x32
			i++
			v := m.Tags[k]
			mapSize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			i = encodeVarintKubemqGo(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Attributes != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Attributes.Size()))
		n1, err := m.Attributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Policy != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Policy.Size()))
		n2, err := m.Policy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *QueueMessagesBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueueMessagesBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagesBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BatchID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.BatchID)))
		i += copy(dAtA[i:], m.BatchID)
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HaveErrors {
		dAtA[i] = 0x18
		i++
		if m.HaveErrors {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *QueueMessageAttributes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessageAttributes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Sequence))
	}
	if len(m.MD5OfBody) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MD5OfBody)))
		i += copy(dAtA[i:], m.MD5OfBody)
	}
	if m.ReceiveCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		dAtA[i] = 0x28
		i++
		if m.ReRouted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReRoutedFromQueue) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ReRoutedFromQueue)))
		i += copy(dAtA[i:], m.ReRoutedFromQueue)
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	return i, nil
}

func (m *QueueMessagePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessagePolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxReceiveCount))
	}
	if len(m.MaxReceiveQueue) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MaxReceiveQueue)))
		i += copy(dAtA[i:], m.MaxReceiveQueue)
	}
	return i, nil
}

func (m *SendQueueMessageResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendQueueMessageResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MessageID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.MessageID)))
		i += copy(dAtA[i:], m.MessageID)
	}
	if m.SentAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.DelayedTo))
	}
	if m.IsError {
		dAtA[i] = 0x28
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *ReceiveQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.MaxNumberOfMessages != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		dAtA[i] = 0x30
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReceiveQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x12
			i++
			i = encodeVarintKubemqGo(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MessagesReceived != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		dAtA[i] = 0x28
		i++
		if m.IsPeak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsError {
		dAtA[i] = 0x30
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *AckAllQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	return i, nil
}

func (m *AckAllQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AckAllQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.AffectedMessages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.AffectedMessages))
	}
	if m.IsError {
		dAtA[i] = 0x18
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *StreamQueueMessagesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if len(m.ClientID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.ClientID)))
		i += copy(dAtA[i:], m.ClientID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if m.VisibilitySeconds != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.ModifiedMessage.Size()))
		n3, err := m.ModifiedMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *StreamQueueMessagesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamQueueMessagesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.RequestID)))
		i += copy(dAtA[i:], m.RequestID)
	}
	if m.StreamRequestTypeData != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(m.Message.Size()))
		n4, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.IsError {
		dAtA[i] = 0x20
		i++
		if m.IsError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintKubemqGo(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func encodeVarintKubemqGo(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedPingResult(r randyKubemqGo, easy bool) *PingResult {
	this := &PingResult{}
	this.Host = string(randStringKubemqGo(r))
	this.Version = string(randStringKubemqGo(r))
	this.ServerStartTime = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerStartTime *= -1
	}
	this.ServerUpTimeSeconds = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ServerUpTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEmpty(r randyKubemqGo, easy bool) *Empty {
	this := &Empty{}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResult(r randyKubemqGo, easy bool) *Result {
	this := &Result{}
	this.EventID = string(randStringKubemqGo(r))
	this.Sent = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEvent(r randyKubemqGo, easy bool) *Event {
	this := &Event{}
	this.EventID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v1 := r.Intn(100)
	this.Body = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Store = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		v2 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v2; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedEventReceive(r randyKubemqGo, easy bool) *EventReceive {
	this := &EventReceive{}
	this.EventID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v3 := r.Intn(100)
	this.Body = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v4; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSubscribe(r randyKubemqGo, easy bool) *Subscribe {
	this := &Subscribe{}
	this.SubscribeTypeData = Subscribe_SubscribeType([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Group = string(randStringKubemqGo(r))
	this.EventsStoreTypeData = Subscribe_EventsStoreType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.EventsStoreTypeValue = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.EventsStoreTypeValue *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRequest(r randyKubemqGo, easy bool) *Request {
	this := &Request{}
	this.RequestID = string(randStringKubemqGo(r))
	this.RequestTypeData = Request_RequestType([]int32{0, 1, 2}[r.Intn(3)])
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v5 := r.Intn(100)
	this.Body = make([]byte, v5)
	for i := 0; i < v5; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Timeout = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Timeout *= -1
	}
	this.CacheKey = string(randStringKubemqGo(r))
	this.CacheTTL = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CacheTTL *= -1
	}
	v6 := r.Intn(100)
	this.Span = make([]byte, v6)
	for i := 0; i < v6; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v7; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedResponse(r randyKubemqGo, easy bool) *Response {
	this := &Response{}
	this.ClientID = string(randStringKubemqGo(r))
	this.RequestID = string(randStringKubemqGo(r))
	this.ReplyChannel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v8 := r.Intn(100)
	this.Body = make([]byte, v8)
	for i := 0; i < v8; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	this.CacheHit = bool(bool(r.Intn(2) == 0))
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Executed = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	v9 := r.Intn(100)
	this.Span = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Span[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v10; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueueMessage(r randyKubemqGo, easy bool) *QueueMessage {
	this := &QueueMessage{}
	this.MessageID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.Metadata = string(randStringKubemqGo(r))
	v11 := r.Intn(100)
	this.Body = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.Body[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v12 := r.Intn(10)
		this.Tags = make(map[string]string)
		for i := 0; i < v12; i++ {
			this.Tags[randStringKubemqGo(r)] = randStringKubemqGo(r)
		}
	}
	if r.Intn(10) != 0 {
		this.Attributes = NewPopulatedQueueMessageAttributes(r, easy)
	}
	if r.Intn(10) != 0 {
		this.Policy = NewPopulatedQueueMessagePolicy(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueueMessagesBatchRequest(r randyKubemqGo, easy bool) *QueueMessagesBatchRequest {
	this := &QueueMessagesBatchRequest{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v13 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v13)
		for i := 0; i < v13; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueueMessagesBatchResponse(r randyKubemqGo, easy bool) *QueueMessagesBatchResponse {
	this := &QueueMessagesBatchResponse{}
	this.BatchID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v14 := r.Intn(5)
		this.Results = make([]*SendQueueMessageResult, v14)
		for i := 0; i < v14; i++ {
			this.Results[i] = NewPopulatedSendQueueMessageResult(r, easy)
		}
	}
	this.HaveErrors = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueueMessageAttributes(r randyKubemqGo, easy bool) *QueueMessageAttributes {
	this := &QueueMessageAttributes{}
	this.Timestamp = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Timestamp *= -1
	}
	this.Sequence = uint64(uint64(r.Uint32()))
	this.MD5OfBody = string(randStringKubemqGo(r))
	this.ReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ReceiveCount *= -1
	}
	this.ReRouted = bool(bool(r.Intn(2) == 0))
	this.ReRoutedFromQueue = string(randStringKubemqGo(r))
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedQueueMessagePolicy(r randyKubemqGo, easy bool) *QueueMessagePolicy {
	this := &QueueMessagePolicy{}
	this.ExpirationSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ExpirationSeconds *= -1
	}
	this.DelaySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.DelaySeconds *= -1
	}
	this.MaxReceiveCount = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxReceiveCount *= -1
	}
	this.MaxReceiveQueue = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSendQueueMessageResult(r randyKubemqGo, easy bool) *SendQueueMessageResult {
	this := &SendQueueMessageResult{}
	this.MessageID = string(randStringKubemqGo(r))
	this.SentAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.SentAt *= -1
	}
	this.ExpirationAt = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.ExpirationAt *= -1
	}
	this.DelayedTo = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.DelayedTo *= -1
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReceiveQueueMessagesRequest(r randyKubemqGo, easy bool) *ReceiveQueueMessagesRequest {
	this := &ReceiveQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.MaxNumberOfMessages = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MaxNumberOfMessages *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedReceiveQueueMessagesResponse(r randyKubemqGo, easy bool) *ReceiveQueueMessagesResponse {
	this := &ReceiveQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Messages = make([]*QueueMessage, v15)
		for i := 0; i < v15; i++ {
			this.Messages[i] = NewPopulatedQueueMessage(r, easy)
		}
	}
	this.MessagesReceived = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesReceived *= -1
	}
	this.MessagesExpired = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.MessagesExpired *= -1
	}
	this.IsPeak = bool(bool(r.Intn(2) == 0))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAckAllQueueMessagesRequest(r randyKubemqGo, easy bool) *AckAllQueueMessagesRequest {
	this := &AckAllQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.Channel = string(randStringKubemqGo(r))
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedAckAllQueueMessagesResponse(r randyKubemqGo, easy bool) *AckAllQueueMessagesResponse {
	this := &AckAllQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.AffectedMessages = uint64(uint64(r.Uint32()))
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStreamQueueMessagesRequest(r randyKubemqGo, easy bool) *StreamQueueMessagesRequest {
	this := &StreamQueueMessagesRequest{}
	this.RequestID = string(randStringKubemqGo(r))
	this.ClientID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	this.Channel = string(randStringKubemqGo(r))
	this.VisibilitySeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.VisibilitySeconds *= -1
	}
	this.WaitTimeSeconds = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.WaitTimeSeconds *= -1
	}
	this.RefSequence = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		this.ModifiedMessage = NewPopulatedQueueMessage(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedStreamQueueMessagesResponse(r randyKubemqGo, easy bool) *StreamQueueMessagesResponse {
	this := &StreamQueueMessagesResponse{}
	this.RequestID = string(randStringKubemqGo(r))
	this.StreamRequestTypeData = StreamRequestType([]int32{0, 1, 2, 3, 4, 5, 6}[r.Intn(7)])
	if r.Intn(10) != 0 {
		this.Message = NewPopulatedQueueMessage(r, easy)
	}
	this.IsError = bool(bool(r.Intn(2) == 0))
	this.Error = string(randStringKubemqGo(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyKubemqGo interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneKubemqGo(r randyKubemqGo) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringKubemqGo(r randyKubemqGo) string {
	v16 := r.Intn(100)
	tmps := make([]rune, v16)
	for i := 0; i < v16; i++ {
		tmps[i] = randUTF8RuneKubemqGo(r)
	}
	return string(tmps)
}
func randUnrecognizedKubemqGo(r randyKubemqGo, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldKubemqGo(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldKubemqGo(dAtA []byte, r randyKubemqGo, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		v17 := r.Int63()
		if r.Intn(2) == 0 {
			v17 *= -1
		}
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(v17))
	case 1:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateKubemqGo(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateKubemqGo(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *PingResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ServerStartTime != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerStartTime))
	}
	if m.ServerUpTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ServerUpTimeSeconds))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Result) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Sent {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Store {
		n += 2
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventReceive) Size() (n int) {
	var l int
	_ = l
	l = len(m.EventID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Subscribe) Size() (n int) {
	var l int
	_ = l
	if m.SubscribeTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.SubscribeTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.EventsStoreTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeData))
	}
	if m.EventsStoreTypeValue != 0 {
		n += 1 + sovKubemqGo(uint64(m.EventsStoreTypeValue))
	}
	return n
}

func (m *Request) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.RequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.RequestTypeData))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timeout))
	}
	l = len(m.CacheKey)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheTTL != 0 {
		n += 1 + sovKubemqGo(uint64(m.CacheTTL))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ReplyChannel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.CacheHit {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Executed {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Span)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueueMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovKubemqGo(uint64(len(k))) + 1 + len(v) + sovKubemqGo(uint64(len(v)))
			n += mapEntrySize + 1 + sovKubemqGo(uint64(mapEntrySize))
		}
	}
	if m.Attributes != nil {
		l = m.Attributes.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.Policy != nil {
		l = m.Policy.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *QueueMessagesBatchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	return n
}

func (m *QueueMessagesBatchResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.BatchID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.HaveErrors {
		n += 2
	}
	return n
}

func (m *QueueMessageAttributes) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovKubemqGo(uint64(m.Timestamp))
	}
	if m.Sequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.Sequence))
	}
	l = len(m.MD5OfBody)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.ReceiveCount))
	}
	if m.ReRouted {
		n += 2
	}
	l = len(m.ReRoutedFromQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	return n
}

func (m *QueueMessagePolicy) Size() (n int) {
	var l int
	_ = l
	if m.ExpirationSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationSeconds))
	}
	if m.DelaySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelaySeconds))
	}
	if m.MaxReceiveCount != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxReceiveCount))
	}
	l = len(m.MaxReceiveQueue)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *SendQueueMessageResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.MessageID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.SentAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.SentAt))
	}
	if m.ExpirationAt != 0 {
		n += 1 + sovKubemqGo(uint64(m.ExpirationAt))
	}
	if m.DelayedTo != 0 {
		n += 1 + sovKubemqGo(uint64(m.DelayedTo))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *ReceiveQueueMessagesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.MaxNumberOfMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.MaxNumberOfMessages))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.IsPeak {
		n += 2
	}
	return n
}

func (m *ReceiveQueueMessagesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovKubemqGo(uint64(l))
		}
	}
	if m.MessagesReceived != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesReceived))
	}
	if m.MessagesExpired != 0 {
		n += 1 + sovKubemqGo(uint64(m.MessagesExpired))
	}
	if m.IsPeak {
		n += 2
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *AckAllQueueMessagesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	return n
}

func (m *AckAllQueueMessagesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.AffectedMessages != 0 {
		n += 1 + sovKubemqGo(uint64(m.AffectedMessages))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *StreamQueueMessagesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.VisibilitySeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.VisibilitySeconds))
	}
	if m.WaitTimeSeconds != 0 {
		n += 1 + sovKubemqGo(uint64(m.WaitTimeSeconds))
	}
	if m.RefSequence != 0 {
		n += 1 + sovKubemqGo(uint64(m.RefSequence))
	}
	if m.ModifiedMessage != nil {
		l = m.ModifiedMessage.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func (m *StreamQueueMessagesResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.RequestID)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.StreamRequestTypeData != 0 {
		n += 1 + sovKubemqGo(uint64(m.StreamRequestTypeData))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	if m.IsError {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovKubemqGo(uint64(l))
	}
	return n
}

func sovKubemqGo(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozKubemqGo(x uint64) (n int) {
	return sovKubemqGo(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *PingResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PingResult{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`ServerStartTime:` + fmt.Sprintf("%v", this.ServerStartTime) + `,`,
		`ServerUpTimeSeconds:` + fmt.Sprintf("%v", this.ServerUpTimeSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Empty) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Empty{`,
		`}`,
	}, "")
	return s
}
func (this *Result) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Result{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Sent:` + fmt.Sprintf("%v", this.Sent) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Event) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Event{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Store:` + fmt.Sprintf("%v", this.Store) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *EventReceive) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&EventReceive{`,
		`EventID:` + fmt.Sprintf("%v", this.EventID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *Subscribe) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Subscribe{`,
		`SubscribeTypeData:` + fmt.Sprintf("%v", this.SubscribeTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`EventsStoreTypeData:` + fmt.Sprintf("%v", this.EventsStoreTypeData) + `,`,
		`EventsStoreTypeValue:` + fmt.Sprintf("%v", this.EventsStoreTypeValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Request) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Request{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`RequestTypeData:` + fmt.Sprintf("%v", this.RequestTypeData) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`CacheKey:` + fmt.Sprintf("%v", this.CacheKey) + `,`,
		`CacheTTL:` + fmt.Sprintf("%v", this.CacheTTL) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *Response) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&Response{`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ReplyChannel:` + fmt.Sprintf("%v", this.ReplyChannel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`CacheHit:` + fmt.Sprintf("%v", this.CacheHit) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Executed:` + fmt.Sprintf("%v", this.Executed) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`Span:` + fmt.Sprintf("%v", this.Span) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessage) String() string {
	if this == nil {
		return "nil"
	}
	keysForTags := make([]string, 0, len(this.Tags))
	for k, _ := range this.Tags {
		keysForTags = append(keysForTags, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForTags)
	mapStringForTags := "map[string]string{"
	for _, k := range keysForTags {
		mapStringForTags += fmt.Sprintf("%v: %v,", k, this.Tags[k])
	}
	mapStringForTags += "}"
	s := strings.Join([]string{`&QueueMessage{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`Metadata:` + fmt.Sprintf("%v", this.Metadata) + `,`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`Tags:` + mapStringForTags + `,`,
		`Attributes:` + strings.Replace(fmt.Sprintf("%v", this.Attributes), "QueueMessageAttributes", "QueueMessageAttributes", 1) + `,`,
		`Policy:` + strings.Replace(fmt.Sprintf("%v", this.Policy), "QueueMessagePolicy", "QueueMessagePolicy", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchRequest{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagesBatchResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagesBatchResponse{`,
		`BatchID:` + fmt.Sprintf("%v", this.BatchID) + `,`,
		`Results:` + strings.Replace(fmt.Sprintf("%v", this.Results), "SendQueueMessageResult", "SendQueueMessageResult", 1) + `,`,
		`HaveErrors:` + fmt.Sprintf("%v", this.HaveErrors) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessageAttributes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessageAttributes{`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Sequence:` + fmt.Sprintf("%v", this.Sequence) + `,`,
		`MD5OfBody:` + fmt.Sprintf("%v", this.MD5OfBody) + `,`,
		`ReceiveCount:` + fmt.Sprintf("%v", this.ReceiveCount) + `,`,
		`ReRouted:` + fmt.Sprintf("%v", this.ReRouted) + `,`,
		`ReRoutedFromQueue:` + fmt.Sprintf("%v", this.ReRoutedFromQueue) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`}`,
	}, "")
	return s
}
func (this *QueueMessagePolicy) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&QueueMessagePolicy{`,
		`ExpirationSeconds:` + fmt.Sprintf("%v", this.ExpirationSeconds) + `,`,
		`DelaySeconds:` + fmt.Sprintf("%v", this.DelaySeconds) + `,`,
		`MaxReceiveCount:` + fmt.Sprintf("%v", this.MaxReceiveCount) + `,`,
		`MaxReceiveQueue:` + fmt.Sprintf("%v", this.MaxReceiveQueue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendQueueMessageResult) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendQueueMessageResult{`,
		`MessageID:` + fmt.Sprintf("%v", this.MessageID) + `,`,
		`SentAt:` + fmt.Sprintf("%v", this.SentAt) + `,`,
		`ExpirationAt:` + fmt.Sprintf("%v", this.ExpirationAt) + `,`,
		`DelayedTo:` + fmt.Sprintf("%v", this.DelayedTo) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`MaxNumberOfMessages:` + fmt.Sprintf("%v", this.MaxNumberOfMessages) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReceiveQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReceiveQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`Messages:` + strings.Replace(fmt.Sprintf("%v", this.Messages), "QueueMessage", "QueueMessage", 1) + `,`,
		`MessagesReceived:` + fmt.Sprintf("%v", this.MessagesReceived) + `,`,
		`MessagesExpired:` + fmt.Sprintf("%v", this.MessagesExpired) + `,`,
		`IsPeak:` + fmt.Sprintf("%v", this.IsPeak) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AckAllQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AckAllQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`AffectedMessages:` + fmt.Sprintf("%v", this.AffectedMessages) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesRequest{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`ClientID:` + fmt.Sprintf("%v", this.ClientID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Channel:` + fmt.Sprintf("%v", this.Channel) + `,`,
		`VisibilitySeconds:` + fmt.Sprintf("%v", this.VisibilitySeconds) + `,`,
		`WaitTimeSeconds:` + fmt.Sprintf("%v", this.WaitTimeSeconds) + `,`,
		`RefSequence:` + fmt.Sprintf("%v", this.RefSequence) + `,`,
		`ModifiedMessage:` + strings.Replace(fmt.Sprintf("%v", this.ModifiedMessage), "QueueMessage", "QueueMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamQueueMessagesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamQueueMessagesResponse{`,
		`RequestID:` + fmt.Sprintf("%v", this.RequestID) + `,`,
		`StreamRequestTypeData:` + fmt.Sprintf("%v", this.StreamRequestTypeData) + `,`,
		`Message:` + strings.Replace(fmt.Sprintf("%v", this.Message), "QueueMessage", "QueueMessage", 1) + `,`,
		`IsError:` + fmt.Sprintf("%v", this.IsError) + `,`,
		`Error:` + fmt.Sprintf("%v", this.Error) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringKubemqGo(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *PingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStartTime", wireType)
			}
			m.ServerStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerStartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerUpTimeSeconds", wireType)
			}
			m.ServerUpTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerUpTimeSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sent = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Store = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subscribe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subscribe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subscribe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscribeTypeData", wireType)
			}
			m.SubscribeTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscribeTypeData |= (Subscribe_SubscribeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeData", wireType)
			}
			m.EventsStoreTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeData |= (Subscribe_EventsStoreType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventsStoreTypeValue", wireType)
			}
			m.EventsStoreTypeValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventsStoreTypeValue |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTypeData", wireType)
			}
			m.RequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTypeData |= (Request_RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheTTL", wireType)
			}
			m.CacheTTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheTTL |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheHit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheHit = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Executed = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Span = append(m.Span[:0], dAtA[iNdEx:postIndex]...)
			if m.Span == nil {
				m.Span = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKubemqGo
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthKubemqGo
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipKubemqGo(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthKubemqGo
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = &QueueMessageAttributes{}
			}
			if err := m.Attributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Policy == nil {
				m.Policy = &QueueMessagePolicy{}
			}
			if err := m.Policy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagesBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagesBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SendQueueMessageResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HaveErrors", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HaveErrors = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessageAttributes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessageAttributes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessageAttributes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MD5OfBody", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MD5OfBody = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveCount", wireType)
			}
			m.ReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRouted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReRouted = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReRoutedFromQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReRoutedFromQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessagePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessagePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessagePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationSeconds", wireType)
			}
			m.ExpirationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelaySeconds", wireType)
			}
			m.DelaySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelaySeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveCount", wireType)
			}
			m.MaxReceiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReceiveCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReceiveQueue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReceiveQueue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendQueueMessageResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendQueueMessageResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendQueueMessageResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentAt", wireType)
			}
			m.SentAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SentAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationAt", wireType)
			}
			m.ExpirationAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayedTo", wireType)
			}
			m.DelayedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayedTo |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumberOfMessages", wireType)
			}
			m.MaxNumberOfMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumberOfMessages |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &QueueMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesReceived", wireType)
			}
			m.MessagesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesReceived |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessagesExpired", wireType)
			}
			m.MessagesExpired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessagesExpired |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPeak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPeak = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AckAllQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AckAllQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AffectedMessages", wireType)
			}
			m.AffectedMessages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AffectedMessages |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= (StreamRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibilitySeconds", wireType)
			}
			m.VisibilitySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VisibilitySeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTimeSeconds", wireType)
			}
			m.WaitTimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTimeSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefSequence", wireType)
			}
			m.RefSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefSequence |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModifiedMessage == nil {
				m.ModifiedMessage = &QueueMessage{}
			}
			if err := m.ModifiedMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamQueueMessagesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamQueueMessagesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamRequestTypeData", wireType)
			}
			m.StreamRequestTypeData = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamRequestTypeData |= (StreamRequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &QueueMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsError = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKubemqGo
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKubemqGo(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthKubemqGo
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKubemqGo(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKubemqGo
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKubemqGo
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthKubemqGo
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowKubemqGo
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipKubemqGo(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthKubemqGo = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKubemqGo   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("kubemq_go.proto", fileDescriptor_kubemq_go_0ff2ba662d4a1703) }

var fileDescriptor_kubemq_go_0ff2ba662d4a1703 = []byte{
	// 1883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xbd, 0x6f, 0x1c, 0xc7,
	0x15, 0xbf, 0xd9, 0xbd, 0x0f, 0xde, 0x23, 0x45, 0x2e, 0x87, 0x0c, 0x7d, 0x3e, 0x09, 0x17, 0x7a,
	0x9d, 0x82, 0x90, 0xe5, 0x33, 0xc3, 0x20, 0xb0, 0x11, 0xc0, 0x46, 0x28, 0x91, 0xb6, 0x14, 0x8b,
	0x96, 0x34, 0x47, 0x29, 0x65, 0xb2, 0xb7, 0x37, 0x3c, 0x6d, 0x78, 0xb7, 0x7b, 0xde, 0x9d, 0xa5,
	0x75, 0x5d, 0x82, 0x20, 0x5d, 0x0a, 0x57, 0x09, 0x92, 0x2a, 0x45, 0x8a, 0xc0, 0x7f, 0x41, 0x90,
	0x34, 0x29, 0x53, 0xba, 0x4c, 0x97, 0x88, 0x41, 0x80, 0x14, 0x29, 0x0c, 0xa4, 0x09, 0x90, 0xc6,
	0x98, 0x8f, 0xdd, 0x9d, 0xfd, 0xb8, 0x93, 0x2c, 0x08, 0xee, 0xe6, 0xbd, 0x79, 0x6f, 0xde, 0x7b,
	0xbf, 0xf7, 0xe6, 0xcd, 0x07, 0x6c, 0x9c, 0xc7, 0x43, 0x3a, 0xfd, 0xf8, 0x47, 0xe3, 0xa0, 0x3f,
	0x0b, 0x03, 0x16, 0xe0, 0xa6, 0x64, 0x74, 0xdf, 0x1c, 0x7b, 0xec, 0x71, 0x3c, 0xec, 0xbb, 0xc1,
	0xf4, 0xad, 0x71, 0x30, 0x0e, 0xde, 0x12, 0xd3, 0xc3, 0xf8, 0x4c, 0x50, 0x82, 0x10, 0x23, 0xa9,
	0x66, 0xff, 0x0a, 0x01, 0xdc, 0xf7, 0xfc, 0x31, 0xa1, 0x51, 0x3c, 0x61, 0x18, 0x43, 0xfd, 0x76,
	0x10, 0xb1, 0x0e, 0xda, 0x45, 0x7b, 0x6d, 0x22, 0xc6, 0xb8, 0x03, 0xad, 0x47, 0x34, 0x8c, 0xbc,
	0xc0, 0xef, 0x18, 0x82, 0x9d, 0x90, 0x78, 0x0f, 0x36, 0x06, 0x34, 0xbc, 0xa0, 0xe1, 0x80, 0x39,
	0x21, 0x3b, 0xf5, 0xa6, 0xb4, 0x63, 0xee, 0xa2, 0x3d, 0x93, 0x14, 0xd9, 0x78, 0x1f, 0xb6, 0x24,
	0xeb, 0xe1, 0x8c, 0xd3, 0x03, 0xea, 0x06, 0xfe, 0x28, 0xea, 0xd4, 0x85, 0x74, 0xd5, 0x94, 0xdd,
	0x82, 0xc6, 0xf1, 0x74, 0xc6, 0xe6, 0xf6, 0x5d, 0x68, 0x2a, 0xe7, 0x3a, 0xd0, 0x3a, 0xbe, 0xa0,
	0x3e, 0xbb, 0x73, 0xa4, 0xfc, 0x4b, 0x48, 0xee, 0xf6, 0x80, 0xfa, 0x4c, 0xf8, 0xb7, 0x42, 0xc4,
	0x18, 0x6f, 0x43, 0xe3, 0x38, 0x0c, 0x83, 0x50, 0xb8, 0xd4, 0x26, 0x92, 0xb0, 0x7f, 0x6e, 0x40,
	0x43, 0x68, 0x2d, 0x59, 0xad, 0x0b, 0x2b, 0xb7, 0x26, 0x9e, 0x9c, 0x92, 0x11, 0xa7, 0x34, 0xd7,
	0xba, 0xf5, 0xd8, 0xf1, 0x7d, 0x3a, 0x51, 0xeb, 0x26, 0x24, 0xd7, 0x3a, 0xa1, 0xcc, 0x19, 0x39,
	0xcc, 0x11, 0x71, 0xb5, 0x49, 0x4a, 0x73, 0xff, 0x6e, 0x06, 0xa3, 0x79, 0xa7, 0xb1, 0x8b, 0xf6,
	0xd6, 0x88, 0x18, 0x73, 0xff, 0x06, 0x2c, 0x08, 0x69, 0xa7, 0x29, 0x9c, 0x96, 0x04, 0x7e, 0x03,
	0xea, 0xa7, 0xce, 0x38, 0xea, 0xb4, 0x76, 0xcd, 0xbd, 0xd5, 0x83, 0x57, 0xfa, 0x32, 0xab, 0x7d,
	0xe1, 0x5a, 0x9f, 0xcf, 0x1c, 0xfb, 0x2c, 0x9c, 0x13, 0x21, 0xd4, 0x7d, 0x1b, 0xda, 0x29, 0x0b,
	0x5b, 0x60, 0x9e, 0xd3, 0xb9, 0x8a, 0x85, 0x0f, 0xb9, 0x85, 0x0b, 0x67, 0x12, 0x53, 0x15, 0x84,
	0x24, 0xbe, 0x67, 0xbc, 0x83, 0xec, 0xdf, 0x18, 0xb0, 0x26, 0x96, 0x24, 0xd4, 0xa5, 0xde, 0x05,
	0x5d, 0x02, 0x86, 0x16, 0xb0, 0xb1, 0x38, 0x60, 0x73, 0x41, 0xc0, 0x75, 0x2d, 0xe0, 0x6b, 0xd0,
	0xe6, 0x09, 0x8e, 0x98, 0x33, 0x9d, 0x09, 0x24, 0x4c, 0x92, 0x31, 0xf8, 0x6a, 0x03, 0xfa, 0x71,
	0x4c, 0x7d, 0x57, 0x22, 0x52, 0x27, 0x29, 0x8d, 0x0f, 0x72, 0xa0, 0xf4, 0x72, 0xa0, 0xa8, 0x08,
	0x5e, 0x1e, 0x36, 0x7f, 0xae, 0x43, 0x7b, 0x10, 0x0f, 0x23, 0x37, 0xf4, 0x86, 0x14, 0x9f, 0xc0,
	0x66, 0x4a, 0x9c, 0xce, 0x67, 0xf4, 0x88, 0x47, 0xcb, 0xd7, 0x59, 0x3f, 0xf8, 0x66, 0xe2, 0x47,
	0x2a, 0xd0, 0xcf, 0x89, 0x92, 0xb2, 0xe6, 0x0b, 0x96, 0xd6, 0x36, 0x34, 0x3e, 0x08, 0x83, 0x78,
	0xa6, 0xea, 0x4a, 0x12, 0x78, 0x00, 0x5b, 0x02, 0x81, 0x48, 0x54, 0x4e, 0xea, 0x5c, 0x43, 0x38,
	0xf7, 0x5a, 0xd9, 0xb9, 0x82, 0x30, 0xa9, 0xd2, 0xc6, 0x07, 0xb0, 0x5d, 0x60, 0x3f, 0x12, 0x30,
	0x35, 0x45, 0xbe, 0x2a, 0xe7, 0x6c, 0x17, 0xae, 0xe4, 0x22, 0xc5, 0x5d, 0xd8, 0xc9, 0x31, 0x1e,
	0xfa, 0x23, 0x7a, 0xe6, 0xf9, 0x74, 0x64, 0xd5, 0x30, 0x40, 0x53, 0x2e, 0x62, 0x21, 0xbc, 0x01,
	0xab, 0xda, 0x82, 0x96, 0x81, 0xd7, 0x60, 0xe5, 0x56, 0x30, 0x9d, 0x3a, 0xfe, 0x28, 0xb2, 0x4c,
	0xbc, 0x0a, 0xad, 0x07, 0x31, 0x0d, 0x3d, 0x1a, 0x59, 0x75, 0xfb, 0xf7, 0x08, 0x36, 0x0a, 0xd6,
	0xf1, 0x35, 0xe8, 0x14, 0x58, 0xba, 0x25, 0x0b, 0xd6, 0x44, 0x03, 0xfa, 0x88, 0x7e, 0x72, 0xcf,
	0x9f, 0xcc, 0x2d, 0x84, 0x31, 0xac, 0x0b, 0xce, 0xfb, 0x61, 0x30, 0x7d, 0xdf, 0x0b, 0x23, 0x66,
	0x19, 0x78, 0x13, 0xae, 0xa4, 0xbc, 0xbb, 0x4e, 0xc4, 0x2c, 0x13, 0x6f, 0xc1, 0x86, 0x60, 0x1d,
	0xb2, 0xa4, 0x02, 0xad, 0x3a, 0xf7, 0x55, 0x31, 0x79, 0xcd, 0x5a, 0x0d, 0xbc, 0x0d, 0x96, 0xc6,
	0x38, 0xa2, 0x13, 0xe6, 0x58, 0x4d, 0xfb, 0x17, 0x75, 0x68, 0x11, 0xae, 0x15, 0x31, 0x5e, 0xf0,
	0x6a, 0x98, 0x6e, 0xab, 0x8c, 0x81, 0x8f, 0x61, 0x43, 0x11, 0x69, 0xea, 0x0c, 0x91, 0xba, 0xab,
	0x49, 0xea, 0xd4, 0x74, 0x5f, 0x13, 0x23, 0x45, 0x9d, 0x5c, 0x45, 0x99, 0x8b, 0x2b, 0xaa, 0xbe,
	0x78, 0xef, 0x36, 0x16, 0xec, 0xdd, 0xa6, 0xb6, 0x77, 0x6d, 0x58, 0x23, 0x74, 0x36, 0x99, 0x27,
	0xcb, 0xb5, 0x84, 0x4e, 0x8e, 0xc7, 0xad, 0x71, 0x24, 0x82, 0x98, 0x75, 0x56, 0x76, 0xd1, 0x5e,
	0x83, 0x24, 0xa4, 0xf0, 0xd1, 0x71, 0x1f, 0xd3, 0x0f, 0xe9, 0xbc, 0xd3, 0x56, 0x3e, 0x2a, 0x3a,
	0x9d, 0x3b, 0x3d, 0xbd, 0xdb, 0x01, 0xa1, 0x96, 0xd2, 0xa2, 0xad, 0xcf, 0x1c, 0xbf, 0xb3, 0x2a,
	0x3d, 0xe1, 0x63, 0xfc, 0xa6, 0xea, 0x05, 0x6b, 0xa2, 0x17, 0xbc, 0x5a, 0xc4, 0xea, 0xa5, 0xb5,
	0x81, 0x77, 0x61, 0x55, 0x83, 0x1a, 0xef, 0x00, 0xd6, 0xc8, 0x87, 0xfe, 0xb9, 0x1f, 0x7c, 0xe2,
	0x5b, 0x35, 0x5e, 0xa3, 0xaa, 0x62, 0x2d, 0x84, 0xdb, 0xd0, 0xe0, 0x05, 0x3b, 0xb7, 0x0c, 0xfb,
	0x67, 0x26, 0xac, 0x10, 0x1a, 0xcd, 0x02, 0x3f, 0xa2, 0xb9, 0x1c, 0xa1, 0x42, 0x8e, 0x72, 0x45,
	0x62, 0x14, 0x8b, 0xa4, 0x88, 0xbb, 0x59, 0x81, 0xfb, 0x57, 0x3d, 0x78, 0x12, 0xc4, 0x6f, 0x7b,
	0x4c, 0x9d, 0x3d, 0x29, 0x9d, 0xef, 0xd1, 0xad, 0x8a, 0x1e, 0x7d, 0xfc, 0x84, 0xba, 0x31, 0xa3,
	0x23, 0x91, 0xe2, 0x15, 0x92, 0xd2, 0xd9, 0x71, 0xdb, 0xd6, 0x8e, 0xdb, 0x34, 0x83, 0xa0, 0x65,
	0xb0, 0xaf, 0x32, 0xb8, 0x2a, 0x32, 0xd8, 0xcd, 0x32, 0x28, 0xd1, 0x7a, 0x79, 0x29, 0xfc, 0xaf,
	0x01, 0x6b, 0x0f, 0x62, 0x1a, 0xd3, 0x13, 0x1a, 0x45, 0xce, 0x98, 0xf7, 0x8b, 0xb6, 0x1a, 0x66,
	0x1b, 0x32, 0x65, 0x7c, 0x4d, 0xc7, 0x7e, 0x72, 0x96, 0x35, 0xf3, 0x67, 0x99, 0xee, 0x67, 0x11,
	0x01, 0xfc, 0x1e, 0xc0, 0x21, 0x63, 0xa1, 0x37, 0x8c, 0x19, 0x8d, 0x44, 0x5a, 0x16, 0x68, 0x66,
	0x52, 0x44, 0xd3, 0xc0, 0x07, 0xd0, 0xbc, 0x1f, 0x4c, 0x3c, 0x77, 0x2e, 0xb2, 0xa6, 0x61, 0xae,
	0xeb, 0x4a, 0x09, 0xa2, 0x24, 0x5f, 0x1c, 0xf5, 0x31, 0xbc, 0xaa, 0x2f, 0x1b, 0xdd, 0x74, 0x98,
	0xfb, 0x38, 0x69, 0x89, 0x1d, 0x68, 0x09, 0x3a, 0xbb, 0x67, 0x28, 0x12, 0xef, 0x73, 0x1c, 0xa5,
	0x46, 0xc7, 0x10, 0xd8, 0x6c, 0x57, 0x79, 0x49, 0x52, 0x29, 0xfb, 0x53, 0x04, 0xdd, 0x2a, 0x4b,
	0x6a, 0xd3, 0x2d, 0x36, 0xf5, 0x0e, 0x6f, 0xd1, 0xfc, 0x46, 0x99, 0x58, 0x4a, 0xb1, 0x1c, 0x50,
	0x7f, 0x94, 0xb3, 0x26, 0xc4, 0x48, 0x22, 0x8e, 0x7b, 0x00, 0xb7, 0x9d, 0x0b, 0x2a, 0x6a, 0x3b,
	0x12, 0x95, 0xb0, 0x42, 0x34, 0x8e, 0xfd, 0x3b, 0x03, 0x76, 0xaa, 0xf3, 0x91, 0xdf, 0x59, 0x68,
	0xd9, 0xed, 0xc7, 0x28, 0xdc, 0x7e, 0x78, 0xd5, 0x1e, 0x7d, 0xf7, 0xde, 0x99, 0x28, 0x25, 0x53,
	0x55, 0x6d, 0xc2, 0x90, 0x1d, 0x42, 0x5c, 0x81, 0x6e, 0x05, 0xb1, 0xcf, 0x44, 0x0d, 0x36, 0x48,
	0x8e, 0xc7, 0x57, 0x27, 0x94, 0x04, 0x62, 0xdf, 0x36, 0xe4, 0xbe, 0x4d, 0x68, 0x7c, 0x03, 0x36,
	0x93, 0x31, 0x3f, 0x02, 0x85, 0xf7, 0xa2, 0x2d, 0xb4, 0x49, 0x79, 0x82, 0x5b, 0x3b, 0x7e, 0x32,
	0xf3, 0x42, 0x87, 0x79, 0x81, 0x7f, 0xc8, 0x54, 0x8b, 0xc8, 0xf1, 0xb8, 0xbf, 0x47, 0x74, 0xe2,
	0xcc, 0xe9, 0xe8, 0x34, 0x10, 0x05, 0x67, 0x92, 0x8c, 0x61, 0xff, 0x09, 0x01, 0x2e, 0x97, 0x1d,
	0x77, 0x23, 0x5b, 0x24, 0x79, 0x1e, 0x20, 0x11, 0x4b, 0x79, 0x82, 0xbb, 0x21, 0x56, 0x4c, 0x04,
	0x0d, 0x19, 0xb4, 0xce, 0xe3, 0x8f, 0x93, 0x13, 0xe7, 0x49, 0x0e, 0x1b, 0x53, 0x88, 0x15, 0xd9,
	0x79, 0x49, 0x09, 0x80, 0xdc, 0xc9, 0x45, 0xb6, 0xfd, 0x17, 0x04, 0x3b, 0xd5, 0x35, 0xf2, 0x8c,
	0xde, 0xb2, 0x03, 0x4d, 0xfe, 0x28, 0x39, 0x94, 0x4f, 0x14, 0x93, 0x28, 0xaa, 0x84, 0xa7, 0xf9,
	0x2c, 0x3c, 0xeb, 0x05, 0x3c, 0x79, 0x99, 0xdf, 0x89, 0x64, 0xe7, 0x95, 0xa9, 0x4d, 0xc8, 0xac,
	0x23, 0x37, 0xf5, 0x07, 0xd0, 0xbf, 0x10, 0x5c, 0xd5, 0x63, 0x4a, 0x36, 0xcf, 0xf3, 0x5d, 0x5a,
	0x5e, 0xac, 0x47, 0xee, 0xc3, 0xd6, 0x89, 0xf3, 0xe4, 0xa3, 0x78, 0x3a, 0xa4, 0xe1, 0xbd, 0xb3,
	0x74, 0x9b, 0xcb, 0x52, 0xad, 0x9a, 0xe2, 0x29, 0xf9, 0xa1, 0xe3, 0x31, 0xfd, 0xad, 0xd8, 0x90,
	0xc9, 0x2b, 0xb0, 0x39, 0xb2, 0x77, 0xa2, 0xfb, 0xd4, 0x39, 0x57, 0x67, 0x99, 0xa2, 0xec, 0x5f,
	0x1a, 0x70, 0xad, 0x3a, 0x4e, 0xd5, 0x1f, 0x96, 0x07, 0xfa, 0x95, 0xdb, 0x11, 0xbe, 0x0e, 0x56,
	0x66, 0x43, 0xd8, 0x1d, 0xa9, 0x82, 0x2b, 0xf1, 0x45, 0xc5, 0x29, 0x9e, 0x48, 0x35, 0x1d, 0x29,
	0x30, 0x8a, 0x6c, 0x2d, 0xbc, 0x86, 0x1e, 0x9e, 0x9e, 0xf6, 0xe6, 0x82, 0xb4, 0xb7, 0xf4, 0xb4,
	0xff, 0x16, 0x41, 0xf7, 0xd0, 0x3d, 0x3f, 0x9c, 0x4c, 0xbe, 0xb6, 0xac, 0x57, 0xe4, 0xb0, 0x5e,
	0x99, 0x43, 0xfb, 0xd7, 0x08, 0xae, 0x56, 0x3a, 0xf7, 0x5c, 0xa9, 0xba, 0x0e, 0xd6, 0xe1, 0xd9,
	0x19, 0x75, 0x19, 0x1d, 0x69, 0x29, 0xe3, 0x3d, 0xb4, 0xc4, 0xd7, 0x61, 0x33, 0x17, 0xc0, 0x56,
	0xd7, 0x61, 0xfb, 0xbf, 0x01, 0xdd, 0x01, 0x0b, 0xa9, 0x33, 0x7d, 0xc9, 0xb0, 0xdd, 0x83, 0x6f,
	0xc8, 0x75, 0x8b, 0x6f, 0x00, 0x53, 0xbc, 0x01, 0xd2, 0x7b, 0x6d, 0x49, 0x88, 0x54, 0xeb, 0x2d,
	0xb9, 0xeb, 0xdf, 0x80, 0xcd, 0x47, 0x5e, 0xe4, 0x0d, 0xbd, 0x89, 0xc7, 0xe6, 0xf9, 0xdd, 0x54,
	0x9e, 0xa8, 0xca, 0x5a, 0xb3, 0x7a, 0xe7, 0xed, 0xf2, 0x1b, 0xf2, 0x59, 0x7a, 0x6c, 0xb5, 0x04,
	0xe4, 0x3a, 0x0b, 0xbf, 0x07, 0x1b, 0x27, 0xc1, 0xc8, 0x3b, 0xf3, 0xd2, 0x0c, 0xa8, 0x0b, 0x48,
	0xf5, 0x5e, 0x2a, 0x0a, 0xdb, 0xff, 0x41, 0x70, 0xb5, 0x12, 0xfd, 0xe7, 0xaa, 0x8b, 0x85, 0x10,
	0x1b, 0x2f, 0x08, 0x71, 0x1f, 0x5a, 0x49, 0x18, 0xe6, 0x92, 0x30, 0x12, 0x21, 0xbd, 0xd8, 0xea,
	0x0b, 0x8a, 0xad, 0xa1, 0x15, 0xdb, 0xf5, 0xcf, 0x10, 0x6c, 0x96, 0x2c, 0xf3, 0x47, 0x6e, 0x89,
	0x99, 0xbd, 0x3f, 0x30, 0xac, 0xab, 0xae, 0xa2, 0xac, 0x5a, 0x08, 0xaf, 0x03, 0x1c, 0xba, 0xe7,
	0x09, 0x2d, 0x9e, 0xb8, 0x84, 0xfe, 0x84, 0xba, 0x2c, 0x61, 0x99, 0xfc, 0xf1, 0x2a, 0xc0, 0x9e,
	0x67, 0x05, 0x60, 0xd5, 0xa5, 0x60, 0x44, 0xfd, 0x24, 0x01, 0x56, 0x03, 0xbf, 0x02, 0x5b, 0xfc,
	0xc0, 0x2b, 0x64, 0xc6, 0x6a, 0x1e, 0xfc, 0xbd, 0x09, 0xea, 0xcb, 0x11, 0xdf, 0x80, 0x36, 0x97,
	0x91, 0xdf, 0x6a, 0x57, 0x72, 0xbf, 0x33, 0xdd, 0x75, 0xed, 0x7a, 0x1f, 0x4f, 0x98, 0x5d, 0xc3,
	0x6f, 0x83, 0x95, 0x4a, 0x47, 0x32, 0xb2, 0x67, 0x2a, 0xed, 0xa1, 0x7d, 0x84, 0xbf, 0xaf, 0x7f,
	0xc5, 0x04, 0x52, 0x1f, 0x6f, 0x96, 0xfe, 0x39, 0xba, 0xdb, 0x55, 0xff, 0x43, 0x76, 0x6d, 0x1f,
	0xe1, 0x77, 0x61, 0x4b, 0x5b, 0x41, 0xe1, 0x59, 0xb9, 0xc6, 0x46, 0xe1, 0x5d, 0x29, 0xd4, 0x0f,
	0x60, 0x95, 0x7b, 0x9e, 0x6c, 0xfe, 0xa2, 0x4c, 0xd7, 0x2a, 0x3e, 0x65, 0xec, 0x1a, 0xfe, 0x36,
	0xac, 0x49, 0x1d, 0x55, 0xb2, 0x25, 0x99, 0x6e, 0x16, 0xbb, 0xf8, 0xee, 0xac, 0xe1, 0x1f, 0x48,
	0x80, 0x72, 0x2f, 0x97, 0xca, 0x4a, 0xeb, 0x3e, 0xe3, 0xde, 0x6a, 0xd7, 0xb0, 0x53, 0xbe, 0xaf,
	0xc8, 0x6b, 0x32, 0x7e, 0xad, 0x6a, 0xc5, 0xdc, 0x65, 0xbd, 0x6b, 0x2f, 0x13, 0x49, 0x23, 0x74,
	0x61, 0xbb, 0xea, 0x9c, 0xc5, 0xaf, 0x67, 0x91, 0x2e, 0xbc, 0x6d, 0x74, 0xbf, 0xb5, 0x5c, 0x48,
	0x33, 0x82, 0xcb, 0x8d, 0x00, 0xdb, 0xf9, 0x2d, 0x5c, 0x69, 0xe1, 0xf5, 0xa5, 0x32, 0x89, 0x01,
	0x51, 0x60, 0x3f, 0x86, 0xad, 0x8a, 0x53, 0x28, 0xb3, 0xb2, 0xf8, 0xfc, 0xcc, 0xac, 0x2c, 0x39,
	0xc6, 0xec, 0x1a, 0x7e, 0x03, 0xea, 0xf7, 0x3d, 0x7f, 0x8c, 0xf3, 0x39, 0xef, 0xe2, 0x84, 0xcc,
	0x7e, 0xe2, 0xed, 0xda, 0xcd, 0x9b, 0x9f, 0x3f, 0xed, 0xd5, 0xfe, 0xf6, 0xb4, 0x57, 0xfb, 0xe2,
	0x69, 0x0f, 0xfd, 0xef, 0x69, 0x0f, 0xfd, 0xf4, 0xb2, 0x87, 0xfe, 0x70, 0xd9, 0x43, 0x7f, 0xbc,
	0xec, 0xa1, 0xbf, 0x5e, 0xf6, 0xd0, 0xe7, 0x97, 0x3d, 0xf4, 0x8f, 0xcb, 0x1e, 0xfa, 0xf7, 0x65,
	0xaf, 0xf6, 0xc5, 0x65, 0x0f, 0x7d, 0xfa, 0xcf, 0x5e, 0xed, 0x33, 0x63, 0xf5, 0xc3, 0x78, 0x48,
	0x4f, 0x1e, 0xf4, 0x3f, 0x08, 0x67, 0xee, 0xb0, 0x29, 0x7e, 0xf9, 0xbf, 0xf3, 0x65, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xde, 0x47, 0x08, 0x17, 0x2f, 0x18, 0x00, 0x00,
}
